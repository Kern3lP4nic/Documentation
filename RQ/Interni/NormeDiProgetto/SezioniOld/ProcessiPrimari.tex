\documentclass[../NormeDiProgetto.tex]{subfiles}
\begin{document}

\section{Processi primari}
   
      \subsection{Processo di fornitura}
            \subsubsection{Studio di fattibilità}
                  Alla pubblicazione dei capitolati d'appalto il responsabile di progetto dovrà fissare un numero di riunioni volte alla discussione e al confronto tra i membri del team. In seguito, gli \analisti\ dovranno redigere lo \studiodifattibilita\ in base a quanto emerso nelle riunioni. \\ Lo  \studiodifattibilita\ sarà articolato nei seguenti punti:
                  \begin{itemize}
                        \item \textbf{Dominio applicativo}: descrizione dell'ambito di utilizzo del prodotto richiesto;
                        \item \textbf{Dominio tecnologico}: descrizione delle tecnologie impiegate nello sviluppo del progetto richiesto;
                        \item \textbf{Criticità}: elenco delle possibili problematiche che potrebbero sorgere durante lo sviluppo del prodotto richiesto, individuando quindi punti critici ed eventuali rischi;
                        \item \textbf{Valutazione finale}: piccolo riassunto finale nel quale verranno spiegate le motivazioni per cui sia stato scelto o scartato il suddetto capitolato.
                  \end{itemize}

      \subsection{Analisi}
            \subsubsection{Analisi dei requisiti}
                  Ultimato lo \studiodifattibilita\ gli \analisti\ dovranno redigere l'\analisideirequisiti\ che dovrà obbligatoriamente essere strutturata nel seguente modo:
                  
                  \paragraph{Classificazione dei requisiti}
                  Dovrà essere redatto un elenco di requisiti emersi durante le riunioni interne e/o esterne. Questo compito spetta agli \analisti. I requisiti dovranno essere classificati secondo la seguente codifica:
                  \begin{equation*}
                        R[Tipo][Importanza][Codice]
                  \end{equation*}
                  dove:
                  \begin{itemize}
                        \item \textbf{Tipo}: può avere i seguenti valori:
                        \begin{itemize}
                              \item \textbf{F}: indica un requisito funzionale;
                              \item \textbf{Q}: indica un requisito di qualità;
                              \item \textbf{P}: indica un requisito prestazionale;
                              \item \textbf{V}: indica un requisito di vincolo.
                        \end{itemize}
                        \item \textbf{Importanza}: può assumere i seguenti valori:
                        \begin{itemize}
                              \item \textbf{O}: indica un requisito obbligatorio;
                              \item \textbf{D}: indica un requisito desiderabile;
                              \item \textbf{F}: indica un requisito facoltativo.
                        \end{itemize}
                        \item \textbf{Codice}: indica il codice identificativo del requisito, è univoco e deve essere indicato in forma gerarchica.
                  \end{itemize}
                  Per ogni requisito si dovrà inoltre indicare:
                  \begin{itemize}
                        \item \textbf{Descrizione}: una breve descrizione, deve essere meno ambigua possibile;
                        \item \textbf{Fonte}: la fonte può essere una delle seguenti:
                        \begin{itemize}
                              \item \textbf{Capitolato}: deriva direttamente dal testo del capitolato;
                              \item \textbf{Verbale}: deriva da un incontro verbalizzato;
                              \item \textbf{Interno}: deriva da discussioni interne al team;
                              \item \textbf{Casi d'uso}: deriva da uno o più casi d'uso.
                        \end{itemize}
                  \end{itemize}
                  
            \subsubsection{Obiettivi di qualità}
			I requisiti identificati dovranno essere gestiti in maniera tale da raggiungere i seguenti traguardi:
			\begin{itemize}
				\item Per ogni requisito verrà tenuta traccia della fonte da cui è stato ricavato;
				\item Per ogni requisito dovrà essere possibile indicare dei test, da effettuare per verificare il soddisfacimento da parte del prodotto;
				\item Per ogni requisito sarà possibile ricostruire i cambiamenti principali effettuati nella sua formulazione, durante tutto il ciclo di sviluppo del prodotto;
				\item Nessun requisito dovrà risultare superfluo o ambiguo;
				\item Tutti i requisiti che il prodotto andrà a soddisfare saranno stati precedentemente approvati dai committenti.
			\end{itemize}
			
				\paragraph{Strategie}
				Tutti i requisiti individuati dovranno essere correttamente inseriti nella piattaforma Trender, la quale si occuperà di mantenere traccia delle fonti dalle quali derivano e della loro implementazione nel prodotto.
			
				\paragraph{Metriche}\mbox{}\\
				\paragraph{Copertura requisiti obbligatori}
			Questa metrica permette di verificare in ogni momento lo stato dell'implementazione dei requisiti obbligatori. Essa controlla infatti il rapporto percentuale tra i requisiti obbligatori soddisfatti e il numero totale dei requisiti obbligatori richiesti.\\
				É possibile calcolarla tramite la formula:
				\begin{equation*}
					Copertura \ requisiti \ obbligatori = \frac{Numero \ di \ requisiti \ obbligatori \ soddisfatti \ * \ 100}{Numero \ totale \ di \ requisiti \ obbligatori}
				\end{equation*}

                  \paragraph{Classificazione dei casi d'uso}
                  I casi d'uso identificati devono essere descritti nel seguente modo:
                  \begin{equation*}
                       UC[Codice padre].[Codice identificativo]
                  \end{equation*}
                  dove:
                  \begin{itemize}
                        \item \textbf{Codice padre}: indica il codice del caso d'uso padre di quello in esame, se non è identificabile è da omettere;
                        \item \textbf{Codice identificativo}: codice univoco e progressivo del caso d'uso in esame.
                  \end{itemize}
                  Per ogni caso d'uso devono inoltre essere identificate le seguenti informazioni:
                  \begin{itemize}
                        \item \textbf{Nome}: indica il nome del caso d'uso;
                        \item \textbf{Attori}: indica gli attori coinvolti nel caso d'uso;
                        \item \textbf{Descrizione}: chiara, precisa e concisa descrizione del caso d'uso;
                        \item \textbf{Precondizione}: indica la situazione che deve essere vera prima dell'esecuzione del caso d'uso;
                        \item \textbf{Postcondizione}: indica la situazione che deve essere vera dopo l'esecuzione del caso d'uso;
                        \item \textbf{Scenario principale}: descrizione composta dal flusso dei casi d'uso figli;
                        \item \textbf{Scenari alternativi}: descrizione composta dai casi d'uso che non appartengono al flusso principale di esecuzione;
                        \item \textbf{Estensioni}: indica quali sono tutte le estensioni, se presenti;
                        \item \textbf{Inclusioni}: indica quali sono tutte le inclusioni, se presenti;
                        \item \textbf{Generalizzazioni}: indica quali sono tutte le generalizzazioni, se presenti.
                  \end{itemize}

      \subsection{Progettazione}
            \subsubsection{Descrizione}
                  L'attività di progettazione descrive come deve essere realizzata la struttura dell'architettura software. I requisiti delineati, all'interno del documento \analisideirequisiti, devono essere utili a realizzare la documentazione specifica e a determinare le linee guida da seguire durante l'attività di codifica. Tale attività deve essere svolta in maniera ottimale e precisa dai Progettisti.

            \subsubsection{Diagrammi}
                  La progettazione deve utilizzare le seguenti tipologie di diagrammi \gl{UML}:
                  \begin{itemize}
                        \item \textbf{Diagrammi di classe}: illustrano una collezione di elementi dichiarativi di un modello come classi e tipi, assieme ai loro contenuti e alle loro relazioni;
                        \item \textbf{Diagrammi dei package}: raggruppamenti di classi in una unità di livello più alto;
                        \item \textbf{Diagrammi di attività}: illustrano il flusso di operazioni relativo ad un'attività; utilizzati soprattutto per descrivere la logica di un algoritmo;
                        \item \textbf{Diagrammi di sequenza}: descrivono una determinata sequenza di azioni dove tutte le scelte sono già state effettuate; in pratica nel diagramma non compaiono scelte, né flussi alternativi.
                  \end{itemize}

            \subsubsection{Requisiti per i progettisti}
                  I progettisti sono responsabili delle attività di progettazione. Essi sono tenuti ad avere:
                  \begin{itemize}
                        \item Profonda conoscenza di tutto ciò che riguarda il processo di sviluppo del software;
                        \item Capacità di saper anticipare i cambiamenti;
                        \item Notevole inventiva per riuscire a trovare una soluzione progettuale accettabile anche in mancanza di una metodologia che sia sufficientemente espressiva;
                        \item Capacità di individuare con rapidità e sicurezza le soluzioni più opportune.
                  \end{itemize}

            \subsubsection{Obiettivi della progettazione}
                  I tipi di diagrammi che dovranno essere prodotti sono:
                  \begin{itemize}
                        \item Progettare un software con le caratteristiche di qualità che sono state dettagliate nella fase di analisi e specifica dei requisiti;
                        \item Capacità di poter far fronte a modifiche da effettuare senza che l'intera struttura del software già costruita debba essere messa nuovamente in discussione ed elaborata;
                        \item Soddisfare i requisiti di qualità fissati dal committente.
                  \end{itemize}

            \subsubsection{Specifica tecnica}
                  La specifica tecnica contiene la progettazione architetturale di alto livello, generale e di ogni singolo componente.
                  Questo documento viene redatto dai Progettisti, che ne faranno da base per la successiva Definizione di prodotto.
                  La specifica tecnica deve basarsi sulla precedente analisi dei requisiti.
                  I contenuti principali del documento saranno quindi:
                  \begin{itemize}
                        \item \textbf{Design pattern}: i \progettisti\ devono fornire una descrizione dei \gl{design pattern} adottati
                        nella definizione dell’architettura. Questa descrizione dovrà essere accompagnata da un
                        diagramma UML, che ne esemplifichi il funzionamento, e dalle motivazioni che hanno
                        portato all’adozione di tale pattern;
                        \item \textbf{Tracciamento delle componenti}: ogni componente dovrà essere tracciato ed associato
                        ad almeno un requisito. In tal modo sarà possibile avere la certezza che tutti i requisiti
                        siano soddisfatti. Tale tracciamento dovrà essere effettuato tramite Trender, che si occupa
                        di generare in modo automatico le relative tabelle;
                        \item \textbf{Test d’integrazione}: i Progettisti devono definire delle strategie di verifica per poter
                        dimostrare la corretta integrazione tra le varie componenti definite.
                  \end{itemize}

                  I tipi di diagrammi che dovranno essere prodotti sono:
                  \begin{itemize}
                        \item Diagrammi dei package;
                        \item Diagrammi di sequenza;
                        \item Diagrammi di attività.
                  \end{itemize}

            \subsubsection{Definizione di prodotto}
                  La Definizione di Prodotto contiene la progettazione di dettaglio del sistema. Lo scopo di questo documento è quello di
                  definire dettagliatamente ogni singola unità di cui è composto il sistema in modo da semplificare
                  l’attività di codifica e allo stesso tempo di non fornire libertà al Programmatore.
                  Parallelamente alla progettazione di dettaglio dei componenti software dovranno essere progettati
                  i relativi test di unità che verranno descritti nel Piano di Qualifica.
                  I contenuti principali del documento saranno quindi:
                  \begin{itemize}
                        \item \textbf{Definizione delle classi}: ogni classe precedentemente progettata viene descritta più nel
                        dettaglio, fornendo una descrizione più approfondita dello scopo, delle sue funzionalità e del
                        suo funzionamento. Per ogni classe dovranno essere anche definiti i vari metodi e attributi
                        che la caratterizzano;
                        \item \textbf{Tracciamento delle classi}: ogni classe deve essere tracciata ed associata ad almeno un
                        requisito, in questo modo è possibile avere la certezza che tutti i requisiti accettati siano
                        soddisfatti e che ogni classe presente nell’architettura soddisfi almeno un requisito;
                        \item \textbf{Test di unità}: i Progettisti devono definire le strategie di verifica delle varie classi in modo
                        che durante l’attività di codifica sia possibile verificare che la classe si comporti in modo
                        corretto.
                  \end{itemize}

                  I tipi di diagrammi che potranno essere contenuti nel documento sono:
                  \begin{itemize}
                        \item Diagrammi dei package;
                        \item Diagrammi delle classi;
                        \item Diagrammi di sequenza.
                  \end{itemize}

            \subsubsection{Norme progettuali}
                  Durante la fase di progettazione i progettisti dovranno rispettare le seguenti direttive.
                  \paragraph{Modularizzazione}
                        I progettisti devono adottare delle tecniche che consentano la scomposizione del sistema in moduli e 
                        definire una descrizione precisa della struttura e delle relazioni che esistono tra i moduli.
                        Questo metodo di sviluppo comporterà i seguenti vantaggi:
                        \begin{itemize}
                              \item Semplificazione della verifica della correttezza semantica e nella correzione di errori;
                              \item Riusabilità del software;
                              \item Leggibilità del codice;
                              \item Testabilità delle singole unità;
                              \item Semplificazione dell’attività di manutenzione.
                        \end{itemize}
                   \paragraph{Modularizzazione AngularJS}
                        Se il progetto prevede l'utilizzo di AngularJS, devono vigere le seguenti linee guida:
                        \begin{itemize}
                              \item Le iterazione di rete devono essere eseguite mediante l'utilizzo di appositi service;
                              \item L'applicazione deve essere suddivisa in moduli indipendenti per ogni utilizzo seguendo il pattern della dependecy injection;
                              \item L'integrazione tra Moduli deve essere testata da appositi test di integrazione;
                              \item Ogni modulo deve essere testato mediante un test di unità;
                              \item E' vietato l'utilizzo di variabili globali o di scope globale.
                        \end{itemize}

                  \paragraph{Modularizzazione Node.js}
                        Se il progetto prevede l'utilizzo di Node.js, devono vigere le seguenti linee guida:
                        \begin{itemize}
                              \item Le iterazione di rete devono essere eseguite mediante l'utilizzo di appositi moduli e classi;
                              \item L'applicazione deve essere suddivisa in moduli indipendenti, ognuno per una diversa funzione;
                              \item L'integrazione tra Moduli deve essere testata da appositi test di integrazione;
                              \item Ogni modulo deve essere testato mediante un test di unità;
                              \item E' vietato l'utilizzo di variabili globali o di scope globale;
                              \item Per la mappa di path, è previsto l'uso di Total.js;
                              \item Per agevolare la compatibilità con i servizi AWS Lambda il modulo principale sarà chiamato main;
                              \item I moduli Node.js saranno rappresentati sui diagrammi UML come classi.
                        \end{itemize}
                        
      		\subsubsection{Obiettivi di qualità}
			Durante lo svolgimento delle attività previste da questo processo, punteremo a definire un'architettura adatta agli scopi del progetto:
			\begin{itemize}
				\item Ogni componente progettato come parte del sistema risulterà essere necessario per il funzionamento del prodotto e costantemente tracciabile ai requisiti che soddisfa;
				\item Il sistema dovrà presentare basso accoppiamento ed alta coesione;
				\item Ogni componente dovrà essere progettato puntando su incapsulamento, modularizzazione e riuso di codice;
				\item Il livello di dettaglio della progettazione dovrà essere tale da poter fare codifica e testing senza bisogno di informazioni aggiuntive, indicando i metodi con i relativi parametri e i campi dati forniti da ciascuna classe;
				\item La struttura a basso livello dell'architettura e le relazioni fra le varie unità software concepite saranno esposte all'interno del documento \definizionediprodotto, che definirà in modo dettagliato cosa implementare;
				\item Oltre alle unità software individuate, le attività permetteranno di definire in modo preciso le interfacce fra esse costituite.
			\end{itemize}
			
			\paragraph{Strategie}
			Durante l'attività di progettazione, sia ad alto livello che di dettaglio, le componenti verranno inserite nella piattaforma Trender, che si occuperà di mantenere aggiornati i tracciamenti fra esse ed i requisiti che soddisfano, oltre alle relazioni presenti fra le varie componenti. Verrà fatta un'analisi dettagliata delle componenti individuate in progettazione architetturale, suddividendo in unità che siano facilmente codificabili e testabili per le attività successive.
			
			\paragraph{Metriche}\mbox{}\\
				\paragraph{Structural Fan-In}
				Permette di misurare, avendo come riferimento un modulo del software, quanti altri moduli lo utilizzano durante la loro esecuzione; si ottiene quindi un indice che stabilisce il livello di riuso implementato.
				\begin{equation*}
					\begin{split}
						&Indice \ numerico \ che \ viene \ incrementato \ nel \ momento \ in \ cui \ viene \ identificato \\
						&un \ modulo \ che, \ durante \ la \ sua \ esecuzione, \ chiama \ il \ modulo \ in \ oggetto
					\end{split}
				\end{equation*}
				
				\paragraph{Structural Fan-Out}
				Permette di misurare, avendo come riferimento un modulo del software, quanti moduli vengono utilizzati durante la sua esecuzione; si ottiene quindi un indice che stabilisce il livello di accoppiamento implementato.
				\begin{equation*}
					\begin{split}
						&Indice \ numerico \ che \ viene \ incrementato \ nel \ momento \ in \ cui \ viene \ identificato \\
						&un \ modulo \ utilizzato \ dal \ modulo \ in \ esame \ durante \ la \ sua \ esecuzione
					\end{split}
				\end{equation*}
				
				\paragraph{Numero di metodi per classe}
			Serve per indicare il numero di metodi definiti in una classe. Un valore molto alto potrebbe indicare una cattiva decomposizione delle funzionalità a livello di progettazione.
			\begin{equation*}
					Indice \ numerico \ che \ indica \ il \ numero \ di \ metodi \ definiti \ in \ una \ classe
				\end{equation*}
			
				\paragraph{Numero di parametri per metodo}
				Un elevato numero di parametri per metodo potrebbe evidenziare un metodo troppo complesso.\\
				Non c'è una regola forte per il numero di parametri possibili in un metodo o costruttore, citando Robert Martin, in Clean Code:\\
\textit{“The ideal number of arguments for a function is zero (niladic). Next comes one (monadic), followed closely by two (dyadic). Three arguments (triadic) should be avoided where possible. More than three (polyadic) requires very special justification – and then shouldn’t be used anyway.“}\\
e Steve McConnell, in Code Complete:\\
\textit{“limit the number of a routine’s parameters to about seven, seven is a magic number for people’s comprehension.”}\\

      \subsection{Codifica}
            \subsubsection{Descrizione}
                  L'attività di codifica ha come obiettivo quello di passare dalla descrizione della soluzione in termini di architettura alla descrizione della soluzione in formato eseguibile da un calcolatore. \\ I \programmatori, responsabili di questa attività, sono tenuti a seguire le linee guida, delineate nell'attività di progettazione, con lo scopo di produrre in output il software designato.

            \subsubsection{Tecniche di scrittura}
                  La definizione di tecniche di scrittura è importante per avere una maggiore comprensione del codice sorgente. Le tecniche di scrittura del codice sono suddivise in tre categorie:
                  \begin{itemize}
                        \item Nomi;
                        \item Commenti;
                        \item Formattazione.
                  \end{itemize}
                  Si è scelto di adottare i metodi proposti nel primo capitolo \textit{Style Guidelines} del libro \gl{\textit{Maintainable JavaScript}} di Nicholas C. Zakas (\url{http://shop.oreilly.com/product/0636920025245.do}(2017-01-29)).
                  
                  \paragraph{Nomi}
                  Lo schema di denominazione rappresenta uno dei supporti più determinanti per la comprensione del flusso logico del software. Di seguito sono riportate le tecniche di denominazione raccomandate:
                  \begin{itemize}
                        \item Assegnare ad ogni elemento un nome univoco e consono alla funzione svolta;
                        \item Evitare nomi poco chiari e suscettibili di interpretazioni soggettive; questo tipo di nome può contribuire a creare ambiguità piuttosto che astrazione;
                        \item Utilizzare la struttura verbo - nome per la denominazione di routine che consentono di eseguire operazioni specifiche su determinati oggetti;
                        \item Poiché la maggior parte dei nomi viene creata concatenando più parole, utilizzare una combinazione di caratteri maiuscoli e minuscoli per semplificarne la lettura;
                        \item Utilizzare un nome significativo anche per le variabili che vengono visualizzate solo in poche righe di codice;
                        \item Utilizzare nomi di variabili composti da una singola lettera, come "i" o "j", esclusivamente per gli indici a ciclo breve;
                        \item Ridurre l'utilizzo delle abbreviazioni ma utilizzare quelle create in maniera coerente. È opportuno che ad ogni abbreviazione corrisponda un solo significato e che a ciascuna parola abbreviata sia associata una sola abbreviazione. Se, ad esempio, si utilizza min come abbreviazione di minimum, in altri contesti non è possibile utilizzare la stessa abbreviazione per minute;
                        \item Nella denominazione di funzioni inserire una descrizione del valore restituito;
                        \item Evitare di utilizzare gli stessi nomi per elementi diversi, ad esempio una routine e una variabile denominate rispettivamente Getname() e iGetname;
                        \item Nella denominazione degli elementi non utilizzare omonimi per evitare ambiguità durante le revisioni del codice;
                        \item Per la denominazione degli elementi evitare l'uso di parole ortograficamente errate;
                        \item È opportuno che nei nomi di file e cartelle sia contenuta una descrizione precisa della relativa funzione.
                  \end{itemize}

                  \paragraph{Commenti}
                  All'interno del codice sorgente è di fondamentale importanza l'inserimento di commenti al fine di
                  facilitare la comprensione del flusso logico. Di seguito sono suggeriti alcuni metodi di inserimento
                  dei commenti:
                  \begin{itemize}
                        \item Quando si modifica il codice mantenere sempre aggiornati i relativi commenti;
                        \item All'inizio di ogni routine è utile fornire commenti predefiniti standard in cui siano indicati
                        le limitazioni, i presupposti e lo scopo della routine. Per commento predefinito si intende
                        una breve introduzione in cui siano illustrate le funzionalità della routine;
                        \item Evitare l'aggiunta di commenti alla fine di una riga di codice; la presenza di commenti a fine
                        riga può rendere più difficoltosa la lettura del codice. Tuttavia questo tipo di commento è
                        valido per l'annotazione di dichiarazioni di variabili. In tal caso è necessario allineare tutti
                        i commenti di fine riga a una tabulazione comune;
                        \item Evitare commenti confusi come righe intere di asterischi. Utilizzare invece spazi vuoti per
                        separare i commenti dal codice;
                        \item Evitare di racchiudere blocchi di commenti in cornici grafiche. Si tratta di un espediente
                        interessante ma di difficile gestione;
                        \item Quando si scrivono commenti, utilizzare frasi di senso compiuto. La funzione dei commenti
                        consiste nel chiarire il significato del codice senza aggiungere alcun tipo di ambiguità;
                        \item Inserire commenti in fase di scrittura del codice, in quanto ciò potrebbe non essere possibile
                        in un secondo momento. Inoltre, se dovesse presentarsi l'opportunità di rivedere il codice
                        scritto, tenere presente che ciò che può essere evidente al momento della stesura potrebbe
                        non esserlo più in futuro;
                        \item Evitare commenti superflui o inappropriati, come annotazioni umoristiche;
                        \item Indicare il funzionamento di tutto ciò che non è chiaro nel codice tramite commenti;
                        \item Per evitare problemi ricorrenti, è opportuno utilizzare sempre i commenti nel caso di codice
                        relativo a correzioni di errori e a potenziali soluzioni;
                        \item Aggiungere commenti al codice costituito da cicli e diramazioni logiche. Si tratta di aree
                        di fondamentale importanza che facilitano la lettura del codice sorgente;
                        \item Creare commenti adottando uno stile uniforme e una struttura e una punteggiatura coerenti;
                        \item Separare i commenti dai delimitatori di commento con spazi vuoti. In questo modo i
                        commenti saranno chiari e facili da individuare.
                  \end{itemize}

                  \paragraph{Formattazione}
                  Una buona e uniforme formattazione facilita la comprensione dell'organizzazione logica del codice. Per consentire agli sviluppatori la decifrazione del codice sorgente è fondamentale una formattazione logica e coerente.
                  Di seguito sono suggeriti alcuni metodi di formattazione:
                  \begin{itemize}
                        \item Definire una dimensione standard per i rientri e utilizzarla in maniera coerente. Allineare le sezioni di codice utilizzando il rientro predefinito;
                        \item Allineare le parentesi di apertura e chiusura utilizzando lo stile \gl{JavaScript}, ovvero con la parentesi di apertura alla fine della linea e quella di chiusura all'inizio della linea. Vari esempi di questo stile possono essere trovati nel libro di riferimento Maintainable JavaScript;
                        \item Rientrare le righe di codice secondo la relativa costruzione logica. Se non viene utilizzato il rientro, il codice risulterà di difficile comprensione;
                        \item Utilizzare spazi prima e dopo la maggior parte degli operatori, se ciò non altera la funzione del codice, per migliorare la leggibilità;
                        \item Utilizzare linee vuote per separare strutturalmente i blocchi di codice sorgente. In questo modo sarà possibile creare "paragrafi" di codice, che consentono di semplificare la comprensione della segmentazione logica del software da parte del lettore;
                        \item Suddividere logicamente il codice sorgente tra diversi file fisici;
                        \item Suddividere le sezioni complesse ed estese di codice in moduli comprensibili di dimensioni minori.
                  \end{itemize}

                  \paragraph{Intestazione File}
                  L’intestazione di ogni file deve contenere obbligatoriamente le seguenti informazioni:
                  \begin{itemize}
                        \item textbf{Name}: nome del file, con riferimento alla Definizione di Prodotto;
                        \item textbf{Description}: descrizione del file, con riferimento alla Definizione di Prodotto;
                        \item textbf{Creation data}: indica la data di creazione del file;
                        \item textbf{Author}: indica l’autore del file;
                        \item textbf{License}: indica il nome della licenza del file;
                        \item textbf{Update history}: indica la cronologia delle modifiche effettuate al file, è così strutturata:
                              \begin{itemize}
                              \item textbf{Update data}: data corrispondente all’ultimo aggiornamento del file;
                              \item textbf{Description}: descrizione della modifica effettuata;
                              \item textbf{Author}: autore dell’ultima modifica.
                              \end{itemize}
                  \end{itemize}

            \subsubsection{Ricorsione}
            La ricorsione va evitata quando possibile. Per ogni funzione ricorsiva sarà necessario fornire una prova di terminazione e sarà necessario valutare il costo in termini di occupazione della memoria. \\
            Nel caso l'utilizzo di memoria risulti troppo elevato la ricorsione dovrà essere rimossa.
		
			\subsubsection{Obiettivi di qualità}
			Le unità software dovranno risultare di qualità. A questo fine ci siamo posti i seguenti obiettivi:
			\begin{itemize}
				\item L'implementazione delle classi e dei metodi definiti in progettazione dovrà puntare a produrre codice a bassa complessità, così che ciò che sarà prodotto sia facilmente comprensibile e testabile;
				\item L'uso di costrutti e tecniche che creano sdoppiamenti del flusso di esecuzione verrà valutato attentamente ed attuato solo se strettamente necessario;
				\item Il codice prodotto dovrà risultare facilmente manutenibile;
				\item Il codice prodotto dovrà risultare privo di elementi inutilizzati;
				\item L'integrazione delle varie parti del sistema sarà completamente automatizzata utilizzando lo strumento di integrazione continua \gl{Jenkins};
				\item Il livello di integrazione raggiunto dal sistema sarà sempre consultabile grazie all'utilizzo dello strumento di integrazione continua Jenkins;
				\item Funzionalità: il prodotto funzionerà sulla base dei requisiti indicati nel documento \analisideirequisitiv;
				\item Affidabilità: il prodotto dovrà essere robusto in presenza di eventuali situazioni di difficoltà;
				\item Usabilità: il prodotto dovrà risultare semplice nell'utilizzo per gli utenti a cui è destinato;
				\item Efficienza: il prodotto dovrà essere performante e rispondere alle richieste dell'utente utilizzando il minor numero di risorse e tempo;
				\item Manutenibilità: il prodotto dovrà essere verificato, stabile e testato ad ogni estensione o modifica;
				\item Portabilità: il prodotto si adatterà con facilità ad ogni trasferimento in diversi sistemi.
			\end{itemize}
			
			\paragraph{Strategie}
			Durante l'attività assegnata, il \programmatore\ dovrà attenersi a quanto indicato nel documento \definizionediprodotto\, prestando attenzione nel cercare di limitare il più possibile la complessità del codice prodotto. Sarà necessario inoltre procedere con la codifica dei test individuati nell'attività di progettazione, in modo tale da consentire la verifica del corretto funzionamento delle varie unità prodotte. Sarà necessario configurare attentamente lo strumento di integrazione continua Jenkins affinché esegua dei test di integrazione di quanto prodotto prima che le ultime modifiche diventino parte del sistema.
			
			\paragraph{Metriche}\mbox{}\\
			\paragraph{Complessità ciclomatica}
			Questa metrica software serve per indicare la complessità di un programma misurando il numero di cammini linearmente indipendenti attraverso il grafo di controllo di flusso. In questo grafo i nodi corrispondono a gruppi indivisibili di istruzioni, mentre gli archi connettono due nodi se il secondo gruppo di istruzioni può essere eseguito immediatamente dopo il primo. È possibile applicare questo indice indistintamente a singole funzioni, \gl{moduli}, metodi e \gl{package} di un programma. Questa metrica viene impiegata per limitare la complessità durante l'attività di sviluppo del prodotto software e può risultare utile durante la fase di test per determinare il numero di casi necessari di questi ultimi. L'indice di complessità, infatti, è un limite superiore al numero di test necessari per raggiungere il coverage completo del modulo testato. Inoltre, uno studio ha mostrato forti corrispondenze tra le metriche di complessità e il livello di coesione nei package presi in esame.\\
			
			\paragraph{Halstead difficulty per function}
				Il livello di difficoltà di una funzione misura la propensione all'errore ed è proporzionale al numero di operatori presenti.\\
				La formula per il calcolo di questo valore è la seguente:
				\begin{equation*}
					D = \frac{n1}{2} * \frac{N2}{n2}
				\end{equation*}
				Dove:
				\begin{itemize}
					\item \textbf{n1}: indica il numero di operatori distinti;
					\item \textbf{N2}: indica il numero totale di operandi;
					\item \textbf{n2}: indica il numero di operandi distinti.
				\end{itemize}

			\paragraph{Halstead volume per function}
			Il volume descrive la dimensione dell'implementazione di un algoritmo e si basa sul numero di operazioni eseguite e sugli operandi di una funzione. Il volume di una funzione senza parametri composta da una sola linea è 20, mentre un indice superiore a 1000 indica che probabilmente la funzione esegue troppe operazioni.
				\\La formula per il calcolo di questo valore è la seguente:
				\begin{equation*}
					V = N * \log_{2}{n}
				\end{equation*}
				Dove:
				\begin{itemize}
					\item \textbf{N}: indica il numero di operatori e di operandi;
					\item \textbf{n}: indica il numero totale di operandi e operatori distinti.
				\end{itemize}

			\paragraph{Halstead effort per function}
				Lo sforzo per implementare o comprendere il significato di una funzione è proporzionale al suo volume e al livello di difficoltà.
				\\La formula per il calcolo di questo valore è la seguente:
				\begin{equation*}
					E = V * D
				\end{equation*}
				Dove:
				\begin{itemize}
					\item \textbf{V}: indica l'Halstead Volume;
					\item \textbf{D}: indica l'Halstead Difficulty.
				\end{itemize}
				
			\paragraph{Maintainability index}
			Questa metrica è una scala logaritmica da -$\infty$ a 171, calcolata sulla base delle linee di codice logiche, della complessità ciclomatica e dall'indice Halstead effort e dove un valore alto indica una maggiore manutenibilità.\\
				
			\paragraph{Produttività di codifica}
				É una metrica utilizzata per indicare la produttività media delle attività di codifica. Una bassa produzione di righe di codice non denota uno scarso impegno, bensì sottolinea l'efficienza di produttività impiegata. \\Il valore si ottiene dalla formula:
				\begin{equation*}
					Produttivit\grave{a} \ di \ codifica = \frac{LOCs}{Ore \ persona}
				\end{equation*}
				Dove:
				\begin{itemize}
					\item \textbf{LOCs}: indica il numero di linee di codice prodotte;
					\item \textbf{Ore persona}: indica il numero di ore produttive dei componenti del gruppo.
				\end{itemize}
			
			\paragraph{Numero di livelli di annidamento}
				Serve per indicare il numero di funzioni o procedure chiamate all'interno di un metodo. Un valore elevato di tale indice denota un'alta complessità ed un basso livello di astrazione del codice.
				\begin{equation*}
					\begin{split}
						&Indice \ numerico \ che \ indica \ il \ numero \ di \ chiamata \ a \ funzioni \ o \ procedure \ presenti \\ 								&all'interno \ di \ un \ metodo
					\end{split}
				\end{equation*}
			
			\paragraph{Variabili inutilizzate}
				Serve per indicare la percentuale di variabili dichiarate che non vengono mai utilizzate durante l'esecuzione.
				Tale valore si ottiene dalla formula:
				\begin{equation*}
					P = \frac{N_{VI}}{N_{VD}} * 100
				\end{equation*}
				Dove:
				\begin{itemize}
					\item \textbf{$N_{VI}$}: indica il numero di variabili che non vengono mai utilizzate;
					\item \textbf{$N_{VD}$}: indica il numero di varibili dichiarate.
				\end{itemize}
			
			\paragraph{Metriche}\mbox{}\\
				\paragraph{Componenti integrate}
				Indica la percentuale di componenti progettate, attualmente implementate e correttamente integrate nel sistema.
				Tale valore si ottiene dalla formula:
				\begin{equation*}
					I = \frac{N_{CI}}{N_{CP}} * 100
				\end{equation*}
				Dove:
				\begin{itemize}
					\item \textbf{$N_{CI}$}: indica il numero di componenti integrate nel sistema;
					\item \textbf{$N_{CP}$}: indica il numero di componenti delineate nell'attività di progettazione.
				\end{itemize}
				
			\paragraph{Completezza dell'implementazione funzionale}
				Indica la percentuale di requisiti funzionali coperti dall'implementazione.
				È possibile calcolarla con la formula seguente:
				\begin{equation*}
					C = (1 - \frac{N_{FM}}{N_{FI}}) * 100
				\end{equation*}
				Dove:
				\begin{itemize}
					\item \textbf{$N_{FM}$}: rappresenta il numero di funzionalità mancanti nell'implementazione;
					 \item \textbf{$N_{FI}$}: indica il numero di funzionalità individuate nell'attività di analisi.
				\end{itemize}

			\paragraph{Accuratezza rispetto alle attese}
				Serve per rilevare la percentuale di risultati che rispecchiano le attese.
				Si può calcolare con la seguente formula:
				\begin{equation*}
					A = (1 - \frac{N_{RD}}{N_{TE}})*100
				\end{equation*}
				Dove:
				\begin{itemize}
					\item \textbf{$N_{RD}$}: rappresenta il numero di test che producono risultati discordanti rispetto alle attese;
					\item \textbf{$N_{TE}$}: indica il numero di test eseguiti.
				\end{itemize}
				

			\paragraph{Controllo degli accessi}
				Permette di conoscere la percentuale di operazioni illegali non bloccate.
				É possibile calcolarla tramite la formula:
				\begin{equation*}
					I = \frac{N_{IE} * 100}{N_{II}}
				\end{equation*}
				Dove:
				\begin{itemize}
					\item \textbf{$N_{IE}$}: rappresenta il numero di operazioni illegali eseguibili dal test;
					\item \textbf{$N_{II}$}: indica il numero di operazioni illegali individuate.
				\end{itemize}

			\paragraph{Copertura requisiti desiderabili}
				Questa metrica permette di verificare in ogni momento lo stato dell'implementazione dei requisiti desiderabili. Essa controlla infatti il rapporto percentuale tra i requisiti desiderabili soddisfatti e il numero totale dei requisiti desiderabili richiesti.\\
			É possibile calcolarla tramite la formula:
				\begin{equation*}
					Copertura \ requisiti \ desiderabili = \frac{Numero \ di \ requisiti \ desiderabili \ soddisfatti \ * \ 100}{Numero \ totale \ di \ requisiti \ desiderabili}
				\end{equation*}
				
			\paragraph{Densità di failure}
				Questa metrica serve per indicare la percentuale di operazioni di testing che si sono concluse in failure. \\La formula per calcolare il valore è la seguente:
				\begin{equation*}
					F = \frac{N_{FR} * 100}{N_{TE}}
				\end{equation*}
				Dove:
				\begin{itemize}
					\item \textbf{$N_{FR}$}: indica il numero di failure rilevati durante la fase di test;
					\item \textbf{$N_{TE}$}: indica il numero di test eseguiti.
				\end{itemize}
				
			\paragraph{Blocco di operazioni non corrette}
				Serve per indicare la percentuale di funzionalità in grado di gestire correttamente i fault che potrebbero verificarsi.
				\begin{equation*}
					B = \frac{N_{FE}}{N_{ON}} * 100
				\end{equation*}
				Dove:
				\begin{itemize}
					\item \textbf{$N_{FE}$}: indica il numero di failure evitati durante la fase di test;
					\item \textbf{$N_{ON}$}: indica il numero di test eseguiti che prevedono l'esecuzione di operazioni non corrette e che possono causare failure.
				\end{itemize}

			\paragraph{Comprensibilità delle funzioni offerte}
				Questa metrica indica la percentuale di operazioni che l'utente riesce a comprendere in modo immediato, senza la consultazione di un manuale.\\La formula per calcolare il valore è la seguente:
				\begin{equation*}
					S = \frac{N_{FC} * 100}{N_{FO}}
				\end{equation*}
				Dove:
				\begin{itemize}
					\item \textbf{$N_{FC}$}: indica il numero di funzionalità comprese in modo immediato dall'utente durante l'attività di test del prodotto;
					\item \textbf{$N_{FO}$}: indica il numero di versioni di funzionalità offerte dal sistema.
				\end{itemize}
				
			\paragraph{Facilità di apprendimento delle funzionalità}
				Serve per indicare il tempo medio impiegato dall'utente per imparare ad usare correttamente una data funzionalità del software.\\
			Per il calcolo di questa metrica viene preso in considerazione il tempo, espresso in minuti, che l'utente impiega per apprendere il corretto funzionamento di una funzionalità offerta dal prodotto.
				
			\paragraph{Consistenza operazionale in uso}
				Indica la percentuale di funzionalità offerte all'utente che rispettano le sue aspettative. La misurazione viene effettuata con la seguente formula:
				\begin{equation*}
					C = (1 - \frac{N_{MFI}}{N_{MFO}}) * 100
				\end{equation*}
				Dove:
				\begin{itemize}
					\item \textbf{$N_{MFI}$}:  rappresenta il numero di funzionalità che non rispettano le aspettative dell'utente;
					\item \textbf{$	N_{MFO}$}:  indica le funzionalità offerte dal sistema.
				\end{itemize}
			
			\paragraph{Capacità di analisi di failure}
				È la percentuale di failure registrate delle quali sono state individuate le cause. Si calcola con la seguente formula:
					\begin{equation*}
						I = (\frac{N_{FI}}{N_{FR}}) * 100
					\end{equation*}
					Dove:
					\begin{itemize}
						\item \textbf{$	N_{FI}$}: rappresenta il numero di failure di cui sono state individuate le cause;
						\item \textbf{$N_{FR}$}: indica il numero di failure rilevate.
					\end{itemize}

			\paragraph{Impatto delle modifiche}
				È la percentuale di modifiche effettuate in risposta a failure che hanno portato all'introduzione di nuove failure in altre componenti del sistema. Si calcola con la seguente formula:
					\begin{equation*}
						I = (\frac{N_{FRF}}{N_{FR}}) * 100
					\end{equation*}
					Dove:
					\begin{itemize}
						\item \textbf{$	N_{FRF}$}: rappresenta il numero di failure risolte, ma che hanno introdotto nuove failure;
						\item \textbf{$N_{RF}$}: indica il numero di failure risolte.
					\end{itemize}

			\paragraph{Versioni dei browser supportate}
				Questa metrica serve per indicare la percentuale di versioni di \gl{browser} attualmente supportate, fra quelle individuate dai requisiti. \\La formula per calcolarne il valore è la seguente:
					\begin{equation*}
						S = \frac{N_{VS} * 100}{N_{VS}}
					\end{equation*}
					Dove:
					\begin{itemize}
						\item \textbf{$N_{VS}$}: rappresenta il numero di versioni di browser supportare dal prodotto;
						\item \textbf{$N_{TE}$}: indica il numero di versioni di browser che devono essere supportare dal prodotto.
					\end{itemize}
					
			\paragraph{Inclusione di funzionalità da altri prodotti}
				Questa metrica serve per indicare la percentuale di funzionalità del software utilizzato in precedenza dall'utente che produce risultati simili a quelli ottenuti dal prodotto da sviluppare. La formula per calcolare questo valore è la seguente:
					\begin{equation*}
						I = \frac{N_{FPA}}{N_{FPP}} * 100
					\end{equation*}
					Dove:
					\begin{itemize}
						\item \textbf{$N_{FPA}$}: indica il numero di funzionalità del software utilizzato in precedenza dall'utente che produce risultati simili a quelli ottenuti dal prodotto in sviluppo;
						\item \textbf{$N_{FPP}$}: indica il numero di funzionalità offerte dal software utilizzato in precedenza dall'utente.
					\end{itemize}
            
            

\end{document}
